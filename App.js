const express = require('express');
const axios = require('axios');
const { Groq } = require('groq-sdk');

const app = express();
const groq = new Groq({
    apiKey: process.env.GROQ_API_KEY
});

// Middleware to parse JSON bodies
app.use(express.json());

// Serve static files (CSS, images, etc.)
app.use(express.static('public'));

// Set up the route for the home page
app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

// Route to fetch CVE data by CVE ID
app.get('/cve-data', async (req, res) => {
    try {
        const cveId = req.query.cveId;
        if (!cveId) {
            throw new Error('CVE ID is required');
        }
        const cveData = await fetchCVEData({ cveId });
        res.json(cveData);
    } catch (error) {
        console.error('Error fetching CVE data:', error);
        res.status(400).json({ error: error.message });
    }
});

// Route to get Groq chat completions
app.get('/groq-completions', async (req, res) => {
    try {
        const cveId = req.query.cveId;
        if (!cveId) {
            throw new Error('CVE ID is required');
        }
        const cveData = await fetchCVEData({ cveId });
        const chatCompletion = await getGroqChatCompletion(cveData);
        
        // Extracting severity information from the fetched data
        const severity = determineSeverity(cveData);
        
        // Updated system response for better engagement
        const systemResponse = "Hello! I'm here to assist you with analyzing CVE data. Let's dive into the details and explore suggestions for mitigating potential risks.";

        const responseData = {
            system_response: systemResponse,
            user_input: cveData.vulnerabilities[0]?.cve?.descriptions[0]?.value || 'No description available',
            model_response: chatCompletion.choices[0]?.message?.content || 'No chat completion available',
            severity: severity
        };
        res.json(responseData);
    } catch (error) {
        console.error('Error getting Groq chat completions:', error);
        res.status(500).json({ error: 'Failed to get Groq chat completions' });
    }
});

// Function to determine the severity based on CVSS metrics
function determineSeverity(cveData) {
    const cvssMetrics = cveData.vulnerabilities[0]?.cve?.metrics?.cvssMetricV31 || [];
    const baseScores = cvssMetrics.map(metric => metric.cvssData.baseScore);
    const maxBaseScore = Math.max(...baseScores);
    
    if (maxBaseScore >= 7.0) {
        return "High";
    } else if (maxBaseScore >= 4.0) {
        return "Medium";
    } else {
        return "Low";
    }
}



// Route to handle chat messages
app.post('/chat', async (req, res) => {
    try {
        const message = req.body.message;
        const botResponse = await generateBotResponse(message);
        res.json({ message: botResponse });
    } catch (error) {
        console.error('Error processing chat message:', error);
        res.status(500).json({ error: 'Failed to process chat message' });
    }
});

async function fetchCVEData(params) {
    try {
        const response = await axios.get('https://services.nvd.nist.gov/rest/json/cves/2.0', { params });
        return response.data;
    } catch (error) {
        console.error('Error fetching CVE data:', error);
        throw new Error('Failed to fetch CVE data');
    }
}

async function getGroqChatCompletion(cveData) {
    try {
        const description = cveData.vulnerabilities[0]?.cve?.descriptions[0]?.value || 'No description available';
        const userMessage = `Analyze CVE data:\n${description}`;
        
        return groq.chat.completions.create({
            messages: [
                { role: "system", content: "You are a helpful assistant. Analyze the CVE data and provide suggestions and mitigations for the specific CVE." },
                { role: "user", content: userMessage }
            ],
            model: "mixtral-8x7b-32768"
        });
    } catch (error) {
        console.error('Error getting Groq chat completions:', error);
        throw new Error('Failed to get Groq chat completions');
    }
}

async function generateBotResponse(message) {
    try {
        const chatCompletion = await groq.chat.completions.create({
            messages: [
                { role: "user", content: message }
            ],
            model: "mixtral-8x7b-32768"
        });

        return chatCompletion.choices[0]?.message?.content || 'No chat completion available';
    } catch (error) {
        console.error('Error generating bot response:', error);
        return 'Failed to generate bot response';
    }
}

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
